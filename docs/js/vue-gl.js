(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):(e=e||self,t(e.VueGL={},e.THREE))})(this,function(e,t){'use strict';var G=Math.PI;function a(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){for(var a,s=0;s<t.length;s++)a=t[s],a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}function s(e,t,a){return t&&i(e.prototype,t),a&&i(e,a),e}function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),a.push.apply(a,i)}return a}function l(e){for(var t,a=1;a<arguments.length;a++)t=null==arguments[a]?{}:arguments[a],a%2?r(Object(t),!0).forEach(function(a){n(e,a,t[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))});return e}function d(e,t){return d=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},d(e,t)}function p(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(t){return!1}}function m(){return m=p()?Reflect.construct:function(e,t,i){var s=[null];s.push.apply(s,t);var a=Function.bind.apply(e,s),n=new a;return i&&d(n,i.prototype),n},m.apply(null,arguments)}function c(e,t){return h(e)||y(e,t)||b()}function u(e){return g(e)||f(e)||v()}function g(e){if(Array.isArray(e)){for(var t=0,a=Array(e.length);t<e.length;t++)a[t]=e[t];return a}}function h(e){if(Array.isArray(e))return e}function f(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function y(e,t){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)){var a=[],i=!0,s=!1,n=void 0;try{for(var r,l=e[Symbol.iterator]();!(i=(r=l.next()).done)&&(a.push(r.value),!(t&&a.length===t));i=!0);}catch(e){s=!0,n=e}finally{try{i||null==l["return"]||l["return"]()}finally{if(s)throw n}}return a}}function v(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function b(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}/**
   * Returns a parsed quaternion object.
   */function S(e){return e.isQuaternion?e:m(t.Quaternion,u(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed vector3 object.
   */function N(e){return e.isVector3?e:m(t.Vector3,u(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed vector2 object.
   */function x(e){return e.isVector2?e:Array.isArray(e)?m(t.Vector2,u(e.map(function(t){return parseFloat(t)}))):m(t.Vector2,u(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed euler object.
   */function w(e){return e.isEuler?e:m(t.Euler,u(e.trim().split(/\s+/).map(function(e,t){return 3===t?e:parseFloat(e)})))}/**
   * Returns a parsed spherical object.
   */function j(e){return e.isSpherical?e:m(t.Spherical,u(e.trim().split(/\s+/).map(function(e){return parseFloat(e)}))).makeSafe()}/**
   * Returns a parsed array.
   */function L(e){return Array.isArray(e)?e:e.split(",")}/**
   * Returns a parsed array of vector2.
   */function V(e){return L(e).map(function(e){return x(e)})}/**
   * Returns a parsed fog object
   */function k(e){return e.isFog?e:m(t.Fog,u(e.trim().split(/\s+/).map(function(e,t){return 0===t?e:parseFloat(e)})))}/**
   * Returns a parsed Color object
   */function A(e){return e.isColor?e:new t.Color(e)}/**
   * Return a parsed name array
   */function M(e){return Array.isArray(e)?e:e.split(" ")}function O(e){return 0<e.length&&!e.includes(" ")}function C(e){return Array.isArray(e)?e.every(function(e){return O(e)}):0<e.length}/**
   * This is the base mixin component for most object components in VueGL,
   * corresponding [THREE.Object3D](https://threejs.org/docs/index.html#api/core/Object3D).
   * Object3d components inside a object3d component are added
   * as children via THREE.Object3D.prototype.add() method.
   *
   * VglObject3d components inside default slots are added as children.
   */ // eslint-disable-next-line import/prefer-default-export
function R(e,t,a){if(e.isPerspectiveCamera)Object.assign(e,{aspect:t/a});else if(e.isOrthographicCamera)Object.assign(e,{left:-t/2,right:t/2,top:a/2,bottom:-a/2});else throw new TypeError("Unknown camera type.");e.updateProjectionMatrix()}/**
   * This component creates a canvas that have WebGL context.
   * Options are corresponding [THREE.WebGLRenderer](https://threejs.org/docs/index.html#api/core/Object3D).
   *
   * Properties of [VglNamespace](../core/vgl-namespace) are also available as mixin.
   */var D=/*#__PURE__*/function(){function e(t){a(this,e),this.parent=t,this.children=[],this.hash=Object.create(null),this.listeners=Object.create(null),this.globalListeners=[],t&&t.children.push(this)}return s(e,[{key:"listen",value:function(e,t){"function"==typeof e?!this.globalListeners.includes(e)&&this.globalListeners.push(e):e in this.listeners?!this.listeners[e].includes(t)&&this.listeners[e].push(t):this.listeners[e]=[t]}},{key:"unlisten",value:function(e,t){if("function"==typeof e){var a=this.globalListeners.indexOf(e);0<=a&&this.globalListeners.splice(a,1)}else{var i=this.listeners[e];if(i)if(1<i.length){var s=i.indexOf(t);0<=s&&i.splice(s,1)}else i[0]===t&&delete this.listeners[e]}}},{key:"get",value:function(e){return e in this.hash?this.hash[e]:this.parent&&this.parent.get(e)}},{key:"set",value:function(e,t){this.hash[e]===t||(this.hash[e]=t,this.emit(e,t))}},{key:"keys",value:function e(){var t=this,e=Object.keys(this.hash);if(!this.parent)return e;var a=this.parent.keys().filter(function(e){return!(e in t.hash)});return[].concat(u(a),u(e))}},{key:"delete",value:function(e,t){this.hash[e]!==t||(delete this.hash[e],this.emit(e,this.parent&&this.parent.get(e)))}},{key:"emit",value:function(e,t){var a=this;e in this.listeners&&this.listeners[e].forEach(function(e){return e(t)}),this.children.forEach(function(a){e in a.hash||a.emit(e,t)}),this.globalListeners.forEach(function(e){return e(a)})}},{key:"destroy",value:function(){if(this.parent){var e=this.parent.children;e.splice(e.indexOf(this),1)}}},{key:"fork",value:function(){return new e(this)}}]),e}(),T={inject:{vglNamespace:{default:function(){return{cameras:new D,scenes:new D}}}},provide:function(){var e=this.vglNamespace,t=e.geometries,a=e.materials,i=e.textures,s=e.object3ds,n=e.curves;return{vglNamespace:Object.create(this.vglNamespace,{geometries:{value:t?t.fork():new D},materials:{value:a?a.fork():new D},textures:{value:i?i.fork():new D},object3ds:{value:s?s.fork():new D},curves:{value:n?n.fork():new D}})}},beforeDestroy:function(){var e=this.vglNamespace,t=e.geometries,a=e.materials,i=e.textures,s=e.object3ds,n=e.curves;t&&t.destroy(),a&&a.destroy(),i&&i.destroy(),s&&s.destroy(),n&&n.destroy()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},B=/*#__PURE__*/function(){function e(t,i){a(this,e),this.listeners=t?t.listeners:[],this.inst=i||function(){}}return s(e,[{key:"listen",value:function(e){this.listeners.includes(e)||this.listeners.push(e)}},{key:"unlisten",value:function(e){var t=this.listeners.indexOf(e);0<=t&&this.listeners.splice(t,1)}},{key:"emit",value:function(){this.listeners.forEach(function(e){return e()})}}]),e}(),P=[String,Number],F=String,z=[String,t.Vector3],E=[String,t.Spherical],U=Boolean,$=[String,t.Euler],H=[String,t.Vector2],q=[String,t.Quaternion],W=[String,Array],I=[String,Array],_=[String,t.Fog],Q=String,K=[String,Array],X={props:{/** The object's local position as a 3D vector. */position:z,/** The object's local rotation as a euler angle. */rotation:$,/**
       * The object's local rotation as a quaternion (specified in x, y, z, w order).
       * Do not use in conjunction with the rotation prop, since they both control the same property
       * of the underlying THREE.Object3D object.
       */rotationQuaternion:q,/** The object's local scale as a 3D vector. */scale:z,/** Whether the object gets rendered into shadow map. */castShadow:U,/** Whether the material receives shadows. */receiveShadow:U,/** Optional name of the object. */name:{type:Q,validator:O},/** Whether the object is visible. */hidden:U},inject:{vglObject3d:{default:function(){return new B}},vglNamespace:{default:function(){throw new Error("VueGL components must be wraped by VglNamespace component.")}}},provide:function(){var e=this;return{vglObject3d:new B(this.vglObject3d,function(){return e.inst})}},computed:{/** The THREE.Object3D instance. */inst:function(){return new t.Object3D},/** The parent THREE.Object3D instance.  */parent:function(){return this.vglObject3d.inst()}},methods:{/** Emit an event in the `object3ds` namespace. */emitAsObject3d:function(){this.vglNamespace.object3ds.emit(this.name,this.inst)}},beforeDestroy:function(){this.inst.parent&&this.inst.parent.remove(this.inst),this.name!==void 0&&(this.vglObject3d.unlisten(this.emitAsObject3d),this.vglNamespace.object3ds.delete(this.name,this.inst))},watch:{inst:{handler:function(e,t){t&&t.parent&&t.parent.remove(t),this.parent&&this.parent.add(e),this.position&&e.position.copy(N(this.position)),this.rotation&&e.rotation.copy(w(this.rotation)),this.rotationQuaternion&&e.quaternion.copy(S(this.rotationQuaternion)),this.scale&&e.scale.copy(N(this.scale)),Object.assign(e,{castShadow:this.castShadow,receiveShadow:this.receiveShadow,visible:!this.hidden,name:this.name}),this.name!==void 0&&this.vglNamespace.object3ds.set(this.name,e),t&&this.vglObject3d.emit()},immediate:!0},parent:function(e){e.add(this.inst)},name:[function(e){this.inst.name=e},{handler:function(e,t){t!==void 0&&(this.vglNamespace.object3ds.delete(t,this.inst),e===void 0&&this.vglObject3d.unlisten(this.emitAsObject3d)),e!==void 0&&(this.vglNamespace.object3ds.set(e,this.inst),t===void 0&&this.vglObject3d.listen(this.emitAsObject3d))},immediate:!0}],position:function(e){this.inst.position.copy(N(e)),this.vglObject3d.emit()},rotation:function(e){this.inst.rotation.copy(w(e)),this.vglObject3d.emit()},rotationQuaternion:function(e){this.inst.quaternion.copy(S(e)),this.vglObject3d.emit()},scale:function(e){this.inst.scale.copy(N(e)),this.vglObject3d.emit()},castShadow:function(e){this.inst.castShadow=e,this.vglObject3d.emit()},receiveShadow:function(e){this.inst.receiveShadow=e,this.vglObject3d.emit()},hidden:function(e){this.inst.visible=!e,this.vglObject3d.emit()}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},Y={mixins:[X],props:{/**
       * Position in 3D space for the camera to point towards.
       * This property overwrite rotation property when both defined.
       */orbitTarget:z,/**
       * Spherical position around orbitTarget.
       * This property overwrite position and rotation properties.
       * If orbitTarget is not defined, automatically set to (0, 0, 0).
       */orbitPosition:E},computed:{/** The THREE.Camera instance. */inst:function(){return new t.Camera}},methods:{/** Emit an event in the `cameras` namespace. */emitAsCamera:function(){this.vglNamespace.cameras.emit(this.name,this.inst)}},created:function(){this.vglObject3d.listen(this.emitAsCamera)},beforeDestroy:function(){this.vglObject3d.unlisten(this.emitAsCamera),this.vglNamespace.cameras.delete(this.name,this.inst)},watch:{inst:{handler:function(e){if(this.orbitPosition||this.orbitTarget){var a;this.orbitTarget&&(a=N(this.orbitTarget)),this.orbitPosition&&(e.position.setFromSpherical(j(this.orbitPosition)),a&&e.position.add(a)),e.lookAt(a||new t.Vector3)}this.vglNamespace.cameras.set(this.name,e)},immediate:!0},name:function(e,t){this.vglNamespace.cameras.delete(t,this.inst),this.vglNamespace.cameras.set(e,this.inst)},orbitTarget:function(e){var t=N(e);this.orbitPosition&&this.inst.position.setFromSpherical(j(this.orbitPosition)).add(t),this.inst.lookAt(t),this.vglObject3d.emit()},orbitPosition:function(e){if(this.inst.position.setFromSpherical(j(e)),this.orbitTarget){var a=N(this.orbitTarget);this.inst.position.add(a),this.inst.lookAt(a)}else this.inst.lookAt(new t.Vector3);this.vglObject3d.emit()}}},Z={mixins:[X],props:{/** CSS style color of the light. */color:{type:F,default:"#fff"},/** Numeric value of the light's strength/intensity. */intensity:{type:P,default:1}},computed:{/** The THREE.Light instance. */inst:function(){return new t.Light}},watch:{inst:{handler:function(e){e.color.setStyle(this.color),Object.assign(e,{intensity:parseFloat(this.intensity)})},immediate:!0},color:function(e){this.inst.color.setStyle(e),this.vglObject3d.emit()},intensity:function(e){this.inst.intensity=parseFloat(e),this.vglObject3d.emit()}}},J={no:t.NoColors,vertex:t.VertexColors,face:t.FaceColors},ee={front:t.FrontSide,back:t.BackSide,double:t.DoubleSide},te={inject:{vglNamespace:{default:function(){throw new Error("VueGL components must be wraped by VglNamespace component.")}}},props:{/** Name of the material. */name:{type:Q,validator:O},/** Defines which side of faces will be rendered. front, back or double. */side:{type:F,default:"front"},/** Defines whether vertex coloring is used. Other options are 'vertex' and 'face'. */vertexColors:{type:F,default:"no"}},computed:{/** The THREE.Material instance. */inst:function(){return new t.Material}},methods:{/**
       * Emit an event in `materials` namespace. Call this method after editing instance's
       * properties.
       */update:function(){this.name!==void 0&&this.vglNamespace.materials.emit(this.name,this.inst)}},watch:{inst:{handler:function(e){e.setValues({side:ee[this.side],vertexColors:J[this.vertexColors]}),this.vglNamespace.materials.set(this.name,e)},immediate:!0},name:function(e,t){t!==void 0&&this.vglNamespace.materials.delete(t,this.inst),e!==void 0&&this.vglNamespace.materials.set(e,this.inst)},side:function(e){this.inst.side=ee[e],this.update()},vertexColors:function(e){this.inst.vertexColors=J[e],this.update()}},beforeDestroy:function(){this.name!==void 0&&this.vglNamespace.materials.delete(this.name,this.inst)},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},ae={inject:{vglNamespace:{default:function(){throw new Error("VueGL components must be wraped by VglNamespace component.")}}},props:{/** Name of the component. */name:{type:Q,validator:O},/** The x, y, and z coordinates of each vertex in this geometry. */positionAttribute:W,/** The red, green, and blue channels of vertex color of each vertex in this geometry. */colorAttribute:W,/** The x, y, and z components of the vertex normal vector of each vertex in this geometry. */normalAttribute:W},computed:{/** The THREE.BufferGeometry instance. */inst:function(){return new t.BufferGeometry}},methods:{/**
       * Emit an event in `geometries` namespace. Call this method after editing instance's
       * properties.
       */update:function(){this.name!==void 0&&this.vglNamespace.geometries.emit(this.name,this.inst)}},beforeDestroy:function(){this.name!==void 0&&this.vglNamespace.geometries.delete(this.name,this.inst),this.inst.dispose()},watch:{inst:{handler:function(e,a){if(this.positionAttribute){var i=a?a.getAttribute("position"):new t.BufferAttribute(new Float32Array(L(this.positionAttribute)),3);e.setAttribute("position",i)}if(this.colorAttribute){var s=a?a.getAttribute("color"):new t.BufferAttribute(new Float32Array(L(this.colorAttribute)),3);e.setAttribute("color",s)}if(this.normalAttribute){var n=a?a.getAttribute("normal"):new t.BufferAttribute(new Float32Array(L(this.normalAttribute)),3);e.setAttribute("normal",n)}a&&a.dispose(),this.vglNamespace.geometries.set(this.name,e)},immediate:!0},name:function(e,t){t!==void 0&&this.vglNamespace.geometries.delete(t,this.inst),e!==void 0&&this.vglNamespace.geometries.set(e,this.inst)},positionAttribute:function(e){var a=L(e),i=this.inst.getAttribute("position");if(i.array.length===a.length)i.copyArray(a);else{/* itemSize / array length is different from previous..
          recreate new Buffer and restore version */var s=i.version;i=new t.BufferAttribute(new Float32Array(a),3),i.version=s,this.inst.setAttribute("position",i)}i.needsUpdate=!0,this.update()},colorAttribute:function(e){var a=L(e),i=this.inst.getAttribute("color");if(i.array.length===a.length)i.copyArray(a);else{/* itemSize / array length is different from previous..
          recreate new Buffer and restore version */var s=i.version;i=new t.BufferAttribute(new Float32Array(a),3),i.version=s,this.inst.setAttribute("color",i)}i.needsUpdate=!0,this.update()},normalAttribute:function(e){var a=L(e),i=this.inst.getAttribute("normal");if(i.array.length===a.length)i.copyArray(a);else{/* itemSize / array length is different from previous..
          recreate new Buffer and restore version */var s=i.version;i=new t.BufferAttribute(new Float32Array(a),3),i.version=s,this.inst.setAttribute("normal",i)}i.needsUpdate=!0,this.update()}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},ie={mixins:[X],methods:{setMaterial:function(){var e=this.vglNamespace.materials,t=this.inst,a=M(this.material).reduce(function(t,a){return e.get(a)?[].concat(u(t),[e.get(a)]):t},[]);t.material=1===a.length?a[0]:a,this.vglObject3d.emit()}},watch:{inst:function(){this.material!==void 0&&this.setMaterial()},material:{handler:function(e,t){var a=this.vglNamespace.materials,i=this.setMaterial;t!==void 0&&M(t).forEach(function(e){return a.unlisten(e,i)}),e!==void 0&&(M(e).forEach(function(e){return a.listen(e,i)}),i())},immediate:!0}},beforeDestroy:function(){var e=this.vglNamespace.materials,t=this.material,a=this.setMaterial;M(t).forEach(function(t){return e.unlisten(t,a)})}},se={mixins:[ie],methods:{setGeometry:function(e){e&&(this.inst.geometry=e,this.vglObject3d.emit(),this.name!==void 0&&this.vglNamespace.object3ds.emit(this.name,this.inst))}},watch:{inst:function(){this.geometry!==void 0&&this.setGeometry(this.vglNamespace.geometries.get(this.geometry))},geometry:{handler:function(e,t){var a=this.vglNamespace.geometries,i=this.setGeometry;t!==void 0&&a.unlisten(t,i),e!==void 0&&(a.listen(e,i),i(a.get(e)))},immediate:!0}},beforeDestroy:function(){this.vglNamespace.geometries.unlisten(this.geometry,this.setGeometry)}},ne={mixins:[te],methods:{setMap:function(){var e=this.vglNamespace.textures,t=this.inst,a=this.map;e.keys().includes(a)&&(t.map=e.get(a)),this.vglNamespace.materials.emit(this.name,t)}},watch:{inst:function(){this.map!==void 0&&this.setMap(this.vglNamespace.textures.get(this.map))},map:{handler:function(e,t){var a=this.vglNamespace.textures,i=this.setMap;t!==void 0&&a.unlisten(t,i),e!==void 0&&(a.listen(e,i),i(a.get(e)))},immediate:!0}},beforeDestroy:function(){this.vglNamespace.textures.unlisten(this.map,this.setMap)}},re={mixins:[ne],props:{/** CSS style color of the material. */color:{type:F,default:"#fff"},/** The color map of the material. */map:F},computed:{/** The THREE.MeshStandardMaterial instance. */inst:function(){return new t.MeshStandardMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e),this.update()}}},le={mixins:[se],props:{/** Name of the geometry, representing the line segment(s). */geometry:{type:Q,validator:O},/** Name of the material for the line. */material:{type:Q,validator:O}},computed:{/** The THREE.Line instance. */inst:function(){return new t.Line}},methods:{computeLineDistances:function(){this.inst.material.isLineDashedMaterial&&this.inst.computeLineDistances()}},beforeDestroy:function(){this.geometry!==void 0&&this.vglNamespace.geometries.unlisten(this.geometry,this.computeLineDistances),this.material!==void 0&&this.vglNamespace.materials.unlisten(this.material,this.computeLineDistances)},watch:{geometry:{handler:function(e,t){t!==void 0&&this.vglNamespace.geometries.unlisten(t,this.computeLineDistances),e!==void 0&&(this.vglNamespace.geometries.listen(e,this.computeLineDistances),this.computeLineDistances())},immediate:!0},material:{handler:function(e,t){t!==void 0&&this.vglNamespace.materials.unlisten(t,this.computeLineDistances),e!==void 0&&(this.vglNamespace.materials.listen(e,this.computeLineDistances),this.computeLineDistances())},immediate:!0}}},oe={mixins:[ae],props:{/** Radius of the cylinder at the top. */radiusTop:{type:P,default:1},/** Radius of the cylinder at the bottom. */radiusBottom:{type:P,default:1},/** Height of the cylinder. */height:{type:P,default:1},/** Number of segmented faces around the circumference of the cylinder. */radialSegments:{type:P,default:8},/** Number of rows of faces along the height of the cylinder. */heightSegments:{type:P,default:1},/** A Boolean indicating whether the ends of the cylinder are open or capped. */openEnded:U,/** Start angle for first segment. */thetaStart:{type:P,default:0},/** The central angle of the circular sector. */thetaLength:{type:P,default:2*G}},computed:{inst:function(){return new t.CylinderBufferGeometry(parseFloat(this.radiusTop),parseFloat(this.radiusBottom),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},de={uv:t.UVMapping,"cube-reflection":t.CubeReflectionMapping,"cube-refraction":t.CubeRefractionMapping,"equirectangular-reflection":t.EquirectangularReflectionMapping,"equirectangular-refraction":t.EquirectangularRefractionMapping,"spherical-reflection":t.SphericalReflectionMapping,"cube-uv-reflection":t.CubeUVReflectionMapping,"cube-uv-refraction":t.CubeUVRefractionMapping},pe={repeat:t.RepeatWrapping,"clamp-to-edge":t.ClampToEdgeWrapping,"mirrored-repeat":t.MirroredRepeatWrapping},me={nearest:t.NearestFilter,"nearest-mip-map-nearest":t.NearestMipMapNearestFilter,"nearest-mip-map-linear":t.NearestMipMapLinearFilter,linear:t.LinearFilter,"linear-mip-map-nearest":t.LinearMipMapNearestFilter,"linear-mip-map-linear":t.LinearMipMapLinearFilter},ce={alpha:t.AlphaFormat,rgb:t.RGBFormat,rgba:t.RGBAFormat,luminance:t.LuminanceFormat,"luminance-alpha":t.LuminanceAlphaFormat,rgbe:t.RGBEFormat,depth:t.DepthFormat,"depth-stencil":t.DepthStencilFormat},ue={"unsigned-byte":t.UnsignedByteType,byte:t.ByteType,short:t.ShortType,"unsigned-short":t.UnsignedShortType,int:t.IntType,"unsigned-int":t.UnsignedIntType,float:t.FloatType,"half-float":t.HalfFloatType,"unsigned-short-4444":t.UnsignedShort4444Type,"unsigned-short-5551":t.UnsignedShort5551Type,"unsigned-short-565":t.UnsignedShort565Type,"unsigned-int-248":t.UnsignedInt248Type},ge={linear:t.LinearEncoding,"s-rgb":t.sRGBEncoding,gamma:t.GammaEncoding,rgbe:t.RGBEEncoding,"log-luv":t.LogLuvEncoding,rgbm7:t.RGBM7Encoding,rgbm16:t.RGBM16Encoding,rgbde:t.RGBDEncoding,"basic-depth":t.BasicDepthPacking,"rgba-depth":t.RGBADepthPacking},he={mixins:[ae],props:{/** The Shape names */shapes:{type:K,validator:C},/** int. Number of points on the curves */curveSegments:P,/** int. Number of points used for subdividing segments
       * along the depth of the extruded spline
       */steps:P,/** float. Depth to extrude the shape */depth:P,/** Apply beveling to the shape */bevelEnabled:U,/** float. How deep into the original shape the bevel goes */bevelThickness:P,/** float. Distance from the shape outline that the bevel extends */bevelSize:P,/** float. Distance from the shape outline that the bevel starts */bevelOffset:P,/** int. Number of bevel layers */bevelSegments:P,/** THREE.Curve. A 3D spline path along which the shape should be extruded */extrudePath:Object,/**  Object that provides UV generator functions */uvGenerator:Object},data:function(){return{shapeNames:[]}},computed:{options:function(){var e=this.curveSegments,t=this.steps,a=this.depth,i=this.bevelEnabled,s=this.bevelThickness,n=this.bevelSize,r=this.bevelOffset,o=this.bevelSegments,d=this.extrudePath,p=this.uvGenerator;return l({},null!=e&&{curveSegments:parseInt(e,10)},{},null!=t&&{steps:parseInt(t,10)},{},null!=a&&{depth:parseFloat(a)},{},null!=i&&{bevelEnabled:i},{},null!=s&&{bevelThickness:parseFloat(s)},{},null!=n&&{bevelSize:parseFloat(n)},{},null!=r&&{bevelOffset:parseFloat(r)},{},null!=o&&{bevelSegments:parseInt(o,10)},{},null!=d&&{extrudePath:d},{},null!=p&&{UVGenerator:p})},inst:function(){var e=this,a=this.shapeNames.map(function(t){var a=c(t,1),i=a[0];return e.vglNamespace.curves.get(i)});return new t.ExtrudeBufferGeometry(a,this.options)}},methods:{/** Update the array of Shape names and Shape UUIDs and emit an event. */setShapeNames:function(){var e=this,t=M(this.shapes);this.shapeNames=t.map(function(t){return[t,e.vglNamespace.curves.get(t).uuid]}),this.update()}},beforeDestroy:function(){var e=this;if(this.shapes!==void 0){var t=M(this.shapes);t.forEach(function(t){e.vglNamespace.curves.unlisten(t,e.setShapeUuids)})}},watch:{shapes:{handler:function(e,t){var a=this,i=t===void 0?[]:M(t),s=e===void 0?[]:M(e);i.forEach(function(e){s.includes(e)||a.vglNamespace.curves.unlisten(e,a.setShapeNames)}),K.forEach(function(e){i.includes(e)||a.vglNamespace.curves.listen(e,a.setShapeNames)}),e!==void 0&&this.setShapeNames()},immediate:!0}}},fe=Object.create(null),ye={mixins:[ne],props:{/** CSS style color of the material. */color:{type:F,default:"#fff"},/** The color map of the material. */map:F,/** Specular color of the material. */specular:{type:F,default:"#111111"},/** How shiny the specular highlight is. A higher value gives a sharper highlight. */shininess:{type:P,default:30}},computed:{/** The THREE.MeshPhongMaterial instance. */inst:function(){return new t.MeshPhongMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{shininess:parseFloat(this.shininess)}),e.specular.setStyle(this.specular),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e),this.update()},specular:function(e){this.inst.specular.setStyle(e),this.update()},shininess:function(e){this.inst.shininess=parseFloat(e),this.update()}}},ve={mixins:[ne],props:{/**
       * Defines custom constants using `#define` directives within the GLSL code for both the vertex
       * shader and the fragment shader; each key/value pair yields another directive:
       * ```
       * defines: {
       *     FOO: 15,
       *     BAR: true
       * }
       * ```
       * yields the lines
       * ```
       * #define FOO 15
       * #define BAR true
       * ```
       * in the GLSL code.
       * @default {}
       */defines:{type:Object,default:function(){return{}}},/**
       * Define whether the material color is affected by global fog settings; true to pass fog
       * uniforms to the shader. Note that changing this value will cause the material to be
       * reconstructed, so be aware of performance if using this reactively. Also note that when using
       * this, THREE expects fog-related uniforms to be defined on your material; you can use
       * something like the following to include them:
       * ```
       * uniforms: THREE.UniformsUtils.merge([
       *    THREE.UniformsLib['fog'],
       *    { other uniforms... }
       * ]),
       * ```
       */fog:{type:U,default:!1},/**
       * Fragment shader GLSL code. This is the actual code for the shader.
       * @default The default fragment shader provided by three.js
       */fragmentShader:{type:F},/**
       * Defines whether this material uses lighting; true to pass uniform data related to lighting to
       * this shader. Note that changing this value will cause the material to be reconstructed, so be
       * aware of performance if using this reactively. Also note that when using this, THREE expects
       * lighting-related uniforms to be defined on your material; you can use something like the
       * following to include them:
       * ```
       * uniforms: THREE.UniformsUtils.merge([
       *    THREE.UniformsLib['lights'],
       *    { other uniforms... }
       * ]),
       * ```
       */lights:{type:U,default:!1},/**
       * Controls wireframe thickness. Due to limitations of the OpenGL Core Profile with the WebGL
       * renderer on most platforms `linewidth` will always be 1 regardless of the set value.
       */linewidth:{type:P,default:1},/** Define whether the material is rendered with flat shading. */flatShading:{type:U,default:!1},/**
       * An object of the form:
       * ```
       * { "uniform1": { value: 1.0 }, "uniform2": { value: 2 } }
       * ```
       * specifying the uniforms to be passed to the shader code; keys are uniform names, values are
       * definitions of the form
       * ```
       * { value: 1.0 }
       * ```
       * where value is the value of the uniform. Names must match the name of the uniform, as defined
       * in the GLSL code. Note that uniforms are refreshed on every frame, so updating the value of
       * the uniform will immediately update the value available to the GLSL code. */uniforms:{type:Object,default:function(){return{}}},/**
       * Vertex shader GLSL code. This is the actual code for the shader.
       * @default The default vertex shader provided by three.js
       */vertexShader:{type:F},/**
       * Render geometry as wireframe (using `GL_LINES` instead of `GL_TRIANGLES`).
       */wireframe:{type:U,default:!1},/**
       * Controls wireframe thickness. Due to limitations of the OpenGL Core Profile with the WebGL
       * renderer on most platforms `linewidth` will always be 1 regardless of the set value.
       */wireframeLinewidth:{type:P,default:1}},computed:{/** The THREE.ShaderMaterial instance. */inst:function(){return new t.ShaderMaterial({fog:this.fog,lights:this.lights})}},watch:{inst:{handler:function(e){Object.assign(e,{defines:this.defines,fog:this.fog,fragmentShader:this.fragmentShader||e.fragmentShader,lights:this.lights,linewidth:parseFloat(this.linewidth),flatShading:this.flatShading,uniforms:this.uniforms,vertexShader:this.vertexShader||e.vertexShader,wireframe:this.wireframe,wireframeLinewidth:parseFloat(this.wireframeLinewidth)})},immediate:!0},defines:{handler:function(e){this.inst.defines=e,this.update()},deep:!0},fragmentShader:function(e){this.inst.fragmentShader=e,this.update()},linewidth:function(e){this.inst.linewidth=parseFloat(e),this.update()},flatShading:function(e){this.inst.flatShading=e,this.update()},uniforms:{handler:function(e){this.inst.uniforms=e,this.update()},deep:!0},vertexShader:function(e){this.inst.vertexShader=e,this.update()},wireframe:function(e){this.inst.wireframe=e,this.update()},wireframeLinewidth:function(e){this.inst.wireframeLinewidth=parseFloat(e),this.update()}}},be={inject:{vglNamespace:{default:function(){throw new Error("VueGL components must be wraped by VglNamespace component.")}}},props:{/** Name of the component. */name:{type:Q,validator:O}},computed:{/** The THREE.Curve instance. */inst:function(){return new t.Curve}},beforeDestroy:function(){this.name!==void 0&&this.vglNamespace.curves.delete(this.name,this.inst)},watch:{inst:{handler:function(e){this.name!==void 0&&this.vglNamespace.curves.set(this.name,e)},immediate:!0},name:function(e,t){t!==void 0&&this.vglNamespace.curves.delete(t,this.inst),e!==void 0&&this.vglNamespace.curves.set(e,this.inst)}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},Se={mixins:[be],props:{/** Whether or not to automatically close the path. */autoClose:U},computed:{/** The THREE.CurvePath instance. */inst:function(){return new t.CurvePath}},watch:{inst:{handler:function(e){Object.assign(e,{autoClose:this.autoClose})},immediate:!0},autoClose:function(e){this.inst.autoClose=e}}},Ne={mixins:[Se],props:{/** The array of points as a LineCurve. */path:I},computed:{/** The THREE.Path instance. */inst:function(){var e=new t.Path;return void 0!==this.path&&e.setFromPoints(V(this.path)),e}}};/**
   * This component provides maps for managing objects by name (string), and also provides utility
   * methods. `vglNamespace` object can be injected to descendant components for using it.
   * It has following namespaces:
   *
   * - `vglNamespace.cameras`
   * - `vglNamespace.scenes`
   * - `vglNamespace.geometries`
   * - `vglNamespace.materials`
   * - `vglNamespace.textures`
   * - `vglNamespace.curves`
   * - `vglNamespace.object3ds`
   *
   * Each namespace internally has a map of strings and objects, and has methods to access them.
   * Each namespace has following methods:
   *
   * - `Namespace.prototype.get(key: string)`
   *   Get an instance corresponding passed `key`.
   * - `Namespace.prototype.set(key: string, inst: any)`
   *   Set an instance corresponding passed `key`.
   * - `Namespace.prototype.delete(key: string, inst: any)`
   *   Delete an instance corresponding passed `key`, only if the instance exactly equals passed
   *   `inst`.
   * - `Namespace.prototype.listen(key: string, callback: func)`
   *   Add a listener function that will be called when the instance corresponding passed key changes.
   * - `Namespace.prototype.unlisten(key: string, callback: func)`
   *   Remove a listener function registered to passed key.
   *
   * When `VglNamespace` components are nested, they create nested namespaces except for `cameras` and
   * `scenes`. Since a nested namespace search instances only in its ancestors, you can use same key
   * string in sibling namespaces.
   */e.VglAmbientLight={mixins:[Z],computed:{/** The THREE.AmbientLight instance. */inst:function(){return new t.AmbientLight}}},e.VglArrowHelper={mixins:[X],props:{/** Direction from origin. */dir:z,/** Length of the arrow. */length:{type:P,default:1},/** Color of the arrow. */color:{type:F,default:"#ff0"},/** The length of the head of the arrow. */headLength:P,/** The width of the head of the arrow. */headWidth:P},computed:{/** The THREE.ArrowHelper instance. */inst:function(){return new t.ArrowHelper(new t.Vector3(0,1,0),new t.Vector3())},/** Array(3) of helper properties. Arrow length, head length, and head width. */len:function(){return[parseFloat(this.length),this.headLength===void 0?void 0:parseFloat(this.headLength),this.headWidth===void 0?void 0:parseFloat(this.headWidth)]}},watch:{inst:{handler:function(e){this.dir&&e.setDirection(N(this.dir).normalize()),e.setLength.apply(e,u(this.len)),e.setColor(new t.Color(this.color))},immediate:!0},dir:function(e){this.inst.setDirection(N(e).normalize()),this.vglObject3d.emit()},len:function(e){var t;(t=this.inst).setLength.apply(t,u(e)),this.vglObject3d.emit()},color:function(e){this.inst.setColor(new t.Color(e)),this.vglObject3d.emit()}}},e.VglAxesHelper={mixins:[X],props:{/** Size of the lines representing the axes. */size:{type:P,default:1}},computed:{/** The THREE.AxesHelper instance. */inst:function(){return new t.AxesHelper(parseFloat(this.size))}}},e.VglBoxGeometry={mixins:[ae],props:{/** Width of the sides on the X axis. */width:{type:P,default:1},/** Height of the sides on the Y axis. */height:{type:P,default:1},/** Depth of the sides on the Z axis. */depth:{type:P,default:1},/** Number of segmented faces along the width of the sides. */widthSegments:{type:P,default:1},/** Number of segmented faces along the height of the sides. */heightSegments:{type:P,default:1},/** Number of segmented faces along the depth of the sides. */depthSegments:{type:P,default:1}},computed:{inst:function(){return new t.BoxBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseFloat(this.depth),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseInt(this.depthSegments,10))}}},e.VglBoxHelper={mixins:[X],props:{/** Size of the lines representing the axes. */color:{type:F,default:"#ff0"},/** Name of the object to show the world-axis-aligned boundingbox. */object:{type:Q,validator:O}},computed:{/** The THREE.BoxHelper instance. */inst:function(){return new t.BoxHelper(void 0,this.color)}},methods:{/** Set the geometry of the helper box from given object. */setFromObject:function(e){this.inst.setFromObject(e)}},beforeDestroy:function(){this.object!==void 0&&this.vglNamespace.object3ds.unlisten(this.object,this.setFromObject)},watch:{inst:function(){this.object!==void 0&&this.setFromObject(this.vglNamespace.object3ds.get(this.object))},object:{handler:function(e,t){var a=this.vglNamespace.object3ds,i=this.setFromObject;t!==void 0&&a.unlisten(t,i),e!==void 0&&(a.listen(e,i),i(this.vglNamespace.object3ds.get(e)))},immediate:!0}}},e.VglCamera=Y,e.VglCameraHelper={mixins:[X],props:{/** Name of the camera to visualize. */camera:{type:Q,required:!0,validator:O}},data:function(){return{/** If camera specified by the name exists or not. Do not set this data manually. */exist:!1}},computed:{/**
       * The THREE.CameraHelper instance. If any cameras specified by the name, it returns a
       * THREE.Object3D instance.
       */inst:function(){if(!this.exist)return new t.Object3D;var e=this.vglNamespace.cameras.get(this.camera);return e.updateProjectionMatrix(),new t.CameraHelper(e)}},methods:{/** Update the helper geometry for given camera object. */update:function(e){return e?void(this.exist=!0,e.updateProjectionMatrix(),this.inst.camera=e,this.inst.update(),this.vglObject3d.emit()):void(this.exist=!1)}},beforeDestroy:function(){this.vglNamespace.cameras.unlisten(this.camera,this.update)},watch:{camera:{handler:function(e,t){t!==void 0&&this.vglNamespace.cameras.unlisten(t,this.update),this.vglNamespace.cameras.listen(e,this.update),this.exist=!!this.vglNamespace.cameras.get(e)},immediate:!0}}},e.VglCircleGeometry={mixins:[ae],props:{/** Radius of the circle. */radius:{type:P,default:1},/** Number of segments (triangles). */segments:{type:P,default:8},/** Start angle for first segment. */thetaStart:{type:P,default:0},/** The central angle of the circular sector. */thetaLength:{type:P,default:2*G}},computed:{inst:function(){return new t.CircleBufferGeometry(parseFloat(this.radius),parseInt(this.segments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglConeGeometry={mixins:[oe],props:{/** Radius of the cone at the base. */radius:{type:P,default:1}},computed:{inst:function(){return new t.ConeBufferGeometry(parseFloat(this.radius),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglCurve=be,e.VglCurvePath=Se,e.VglCylinderGeometry=oe,e.VglDirectionalLight={mixins:[Z],computed:{/** The THREE.DirectionalLight instance. */inst:function(){return new t.DirectionalLight}}},e.VglDirectionalLightHelper={mixins:[X],props:{/** If this is not the set the helper will take the color of the light. */color:{type:F},/** Dimensions of the plane. */size:{type:P,default:1},/** Name of the directional light being visualized. */light:F},data:function(){return{/**
         * Light object's UUID. This would be null if light object is not specified by `light` prop. Do
         * not set this data manually.
         */lightUuid:null}},computed:{/**
       * The THREE.DirectionalLightHelper instance. If any cameras specified by the name, it returns
       * a THREE.Object3D instance.
       */inst:function(){if(!this.lightUuid)return new t.Object3D;var e=this.vglNamespace.object3ds.get(this.light);return new t.DirectionalLightHelper(e,parseFloat(this.size))}},methods:{/** Set `lightUuid` data to given object's UUID. */setLightUuid:function(e){this.lightUuid=e?e.uuid:null,this.inst.update()}},beforeDestroy:function(){this.light!==void 0&&this.vglNamespace.object3ds.unlisten(this.light,this.setLightUuid)},watch:{inst:function(e){this.lightUuid&&this.color!==void 0&&Object.assign(e,{color:this.color}).update()},light:{handler:function(e,t){if(void 0!==t&&this.vglNamespace.object3ds.unlisten(t,this.setLightUuid),void 0!==e){this.vglNamespace.object3ds.listen(e,this.setLightUuid);var a=this.vglNamespace.object3ds.get(this.light);this.setLightUuid(a)}},immediate:!0},color:{handler:function(e){this.lightUuid&&(this.inst.color=e,this.inst.update())},immediate:!0}}},e.VglDodecahedronGeometry={mixins:[ae],props:{/** Radius of the dodecahedron. */radius:{type:P,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a dodecahedron. */detail:{type:P,default:0}},computed:{inst:function(){return new t.DodecahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglExtrudeGeometry=he,e.VglGeometry=ae,e.VglGridHelper={mixins:[X],props:{/** The size of the grid. */size:{type:P,default:10},/** The number of divisions across the grid. */divisions:{type:P,default:10},/** The color of the centerline. */colorCenterLine:{type:F,default:"#444444"},/** The color of the lines of the grid. */colorGrid:{type:F,default:"#888888"}},computed:{/** The THREE.GridHelper instance. */inst:function(){return new t.GridHelper(parseFloat(this.size),parseInt(this.divisions,10),this.colorCenterLine,this.colorGrid)}}},e.VglGroup={mixins:[X],computed:{/** The THREE.Group instance. */inst:function(){return new t.Group}}},e.VglHemisphereLight={mixins:[Z],props:{/** The light's ground color */groundColor:{type:F,default:"#fff"}},computed:{/** The THREE.HemisphereLight instance. */inst:function(){return new t.HemisphereLight}},watch:{inst:{handler:function(e){e.groundColor.setStyle(this.groundColor)},immediate:!0},groundColor:function(e){this.inst.groundColor.setStyle(e),this.vglObject3d.emit()}}},e.VglIcosahedronGeometry={mixins:[ae],props:{/** Radius of the icosahedron. */radius:{type:P,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a icosahedron. */detail:{type:P,default:0}},computed:{inst:function(){return new t.IcosahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglLatheGeometry={mixins:[ae],props:{/** Array of Vector2s. The x-coordinate of each point must be greater than zero. */points:{type:I,required:!0},/** The number of circumference segments to generate. */segments:{type:P,default:12},/** The starting angle in radians. */phiStart:{type:P,default:0},/** The radian (0 to 2PI) range of the lathed section. */phiLength:{type:P,default:2*G}},computed:{inst:function(){return new t.LatheBufferGeometry(V(this.points),parseInt(this.segments,10),parseFloat(this.phiStart),parseFloat(this.phiLength))}}},e.VglLight=Z,e.VglLine=le,e.VglLineBasicMaterial={mixins:[te],props:{/** CSS style color of the material. */color:{type:F,default:"#fff"},/** The line thickness. */linewidth:{type:P,default:1},/** Define appearance of line ends. Possible values are "butt", "round" and "square". */linecap:{type:F,default:"round"},/** Define appearance of line joints. Possible values are "round", "bevel" and "miter". */linejoin:{type:F,default:"round"}},computed:{/** The THREE.LineBasicMaterial instance. */inst:function(){return new t.LineBasicMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{linecap:this.linecap,linejoin:this.linejoin,linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e),this.update()},linewidth:function(e){this.inst.linewidth=parseFloat(e),this.update()},linecap:function(e){this.inst.linecap=e,this.update()},linejoin:function(e){this.inst.linejoin=e,this.update()}}},e.VglLineDashedMaterial={mixins:[te],props:{/** CSS style color of the material. */color:{type:F,default:"#fff"},/** The line thickness. */linewidth:{type:P,default:1},/** The size of the dash. This is both the gap with the stroke. */dashSize:{type:P,default:3},/** The size of the gap. */gapSize:{type:P,default:1}},computed:{/** The THREE.LineDashedMaterial instance. */inst:function(){return new t.LineDashedMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{dashSize:parseFloat(this.dashSize),gapSize:parseFloat(this.gapSize),linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e),this.update()},linewidth:function(e){this.inst.linewidth=parseFloat(e),this.update()},dashSize:function(e){this.inst.dashSize=parseFloat(e),this.update()},gapSize:function(e){this.inst.gapSize=parseFloat(e),this.update()}}},e.VglLineLoop={mixins:[le],computed:{/** The THREE.LineLoop instance. */inst:function(){return new t.LineLoop}}},e.VglLineSegments={mixins:[le],computed:{/** The THREE.LineSegments instance. */inst:function(){return new t.LineSegments}}},e.VglMaterial=te,e.VglMesh={mixins:[se],props:{/** Name of the geometry, defining the object's structure. */geometry:{type:Q,validator:O},/**
       * A Material name or an array of Material name, defining the object's appearance.
       *
       * A single material will apply the material to all object's faces meanwhile
       * an array of material will apply each material to the matching index object's face
       */material:{type:K,validator:C}},computed:{/** The THREE.Mesh instance. */inst:function(){return new t.Mesh}}},e.VglMeshBasicMaterial={mixins:[ne],props:{/** CSS style color of the material. */color:{type:F,default:"#fff"},/** The color map of the material. */map:F},computed:{/** The THREE.MeshBasicMaterial instance. */inst:function(){return new t.MeshBasicMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e),this.update()}}},e.VglMeshDepthMaterial={mixins:[ne],props:{/** Whether the material is affected by fog. */fog:U,/** The color map of the material. */map:F},computed:{/** The THREE.MeshDepthMaterial instance. */inst:function(){return new t.MeshDepthMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e,this.update()}}},e.VglMeshLambertMaterial={mixins:[ne],props:{/** CSS style color of the material. */color:{type:F,default:"#fff"},/** The color map of the material. */map:F},computed:{/** The THREE.MeshLambertMaterial instance. */inst:function(){return new t.MeshLambertMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e),this.update()}}},e.VglMeshNormalMaterial={mixins:[te],props:{/** Whether the material is affected by fog. */fog:U},computed:{/** The THREE.MeshNormalMaterial instance. */inst:function(){return new t.MeshNormalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e,this.update()}}},e.VglMeshPhongMaterial=ye,e.VglMeshPhysicalMaterial={mixins:[re],props:{/** ClearCoat level, from 0.0 to 1.0. */clearcoat:{type:P,default:0},/** How rough the clearCoat appears, from 0.0 to 1.0. */clearcoatRoughness:{type:P,default:0},/** Degree of reflectivity, from 0.0 to 1.0. */reflectivity:{type:P,default:.5}},computed:{/** The THREE.MeshPhysicalMaterial instance. */inst:function(){return new t.MeshPhysicalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{clearcoat:parseFloat(this.clearcoat),clearcoatRoughness:parseFloat(this.clearcoatRoughness),reflectivity:parseFloat(this.reflectivity)})},immediate:!0},clearcoat:function(e){this.inst.clearcoat=parseFloat(e),this.update()},clearcoatRoughness:function(e){this.inst.clearcoatRoughness=parseFloat(e),this.update()},reflectivity:function(e){this.inst.reflectivity=parseFloat(e),this.update()}}},e.VglMeshStandardMaterial=re,e.VglMeshToonMaterial={mixins:[ye],computed:{/** The THREE.MeshToonMaterial instance. */inst:function(){return new t.MeshToonMaterial}}},e.VglNamespace=T,e.VglObject3d=X,e.VglOctahedronGeometry={mixins:[ae],props:{/** Radius of the octahedron. */radius:{type:P,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a octahedron. */detail:{type:P,default:0}},computed:{inst:function(){return new t.OctahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglOrthographicCamera={mixins:[Y],props:{/** Zoom factor of the camera. */zoom:{type:P,default:1},/** Camera frustum near plane. */near:{type:P,default:.1},/** Camera frustum far plane. */far:{type:P,default:2e3}},computed:{/** The THREE.OrthographicCamera instance. */inst:function(){return new t.OrthographicCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far)})},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.vglObject3d.emit()},near:function(e){this.inst.near=parseFloat(e),this.vglObject3d.emit()},far:function(e){this.inst.far=parseFloat(e),this.vglObject3d.emit()}}},e.VglPath=Ne,e.VglPerspectiveCamera={mixins:[Y],props:{/** Zoom factor of the camera. */zoom:{type:P,default:1},/** Camera frustum near plane. */near:{type:P,default:.1},/** Camera frustum far plane. */far:{type:P,default:2e3},/** Camera frustum vertical field of view, from bottom to top of view, in degrees. */fov:{type:P,default:50}},computed:{/** The THREE.PerspectiveCamera instance. */inst:function(){return new t.PerspectiveCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far),fov:parseFloat(this.fov)})},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.vglObject3d.emit()},near:function(e){this.inst.near=parseFloat(e),this.vglObject3d.emit()},far:function(e){this.inst.far=parseFloat(e),this.vglObject3d.emit()},fov:function(e){this.inst.fov=parseFloat(e),this.vglObject3d.emit()}}},e.VglPlaneGeometry={mixins:[ae],props:{/** Width along the X axis. */width:{type:P,default:1},/** Height along the Y axis. */height:{type:P,default:1},/** Number of segments along the X axis. */widthSegments:{type:P,default:1},/** Number of segments along the Y axis. */heightSegments:{type:P,default:1}},computed:{inst:function(){return new t.PlaneBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10))}}},e.VglPointLight={mixins:[Z],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:P,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:P,default:1}},computed:{/** The THREE.PointLight instance. */inst:function(){return new t.PointLight}},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay)})},immediate:!0},distance:function(e){this.inst.distance=parseFloat(e),this.vglObject3d.emit()},decay:function(e){this.inst.decay=parseFloat(e),this.vglObject3d.emit()}}},e.VglPoints={mixins:[se],props:{/** Name of the geometry, defining the object's structure. */geometry:{type:Q,validator:O},/** Name of the material, defining the object's appearance. */material:{type:Q,validator:O}},computed:{/** The THREE.Points instance. */inst:function(){return new t.Points}}},e.VglPointsMaterial={mixins:[te],props:{/** CSS style color of the material. */color:{type:F,default:"#fff"},/** The size of the points. */size:{type:P,default:1},/** Specify whether points' size will get smaller with the distance. */disableSizeAttenuation:U},computed:{/** The THREE.PointsMaterial instance. */inst:function(){return new t.PointsMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{size:parseFloat(this.size),sizeAttenuation:!this.disableSizeAttenuation}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e),this.update()},size:function(e){this.inst.size=parseFloat(e),this.update()},disableSizeAttenuation:function(e){this.inst.sizeAttenuation=!e,this.update()}}},e.VglPolarGridHelper={mixins:[X],props:{/** The radius of the polar grid. This can be any positive number. */radius:{type:P,default:10},/** The number of radial lines. This can be any positive integer. */radials:{type:P,default:16},/** The number of circles. This can be any positive integer. */circles:{type:P,default:8},/**
       * The number of line segments used for each circle.
       * This can be any positive integer that is 3 or greater.
       */divisions:{type:P,default:64},/** The first color used for grid elements. */color1:{type:F,default:"#444444"},/** The second color used for grid elements. */color2:{type:F,default:"#888888"}},computed:{/** The THREE.PolarGridHelper instance. */inst:function(){return new t.PolarGridHelper(parseFloat(this.radius),parseInt(this.radials,10),parseInt(this.circles,10),parseInt(this.divisions,10),this.color1,this.color2)}}},e.VglRectAreaLight={mixins:[Z],props:{/** Width of the light. */width:{type:P,default:10},/** Height of the light. */height:{type:P,default:10}},computed:{/** The THREE.RectAreaLight instance. */inst:function(){return new t.RectAreaLight}},watch:{inst:{handler:function(e){Object.assign(e,{width:parseFloat(this.width),height:parseFloat(this.height)})},immediate:!0},width:function(e){this.inst.width=parseFloat(e),this.vglObject3d.emit()},height:function(e){this.inst.height=parseFloat(e),this.vglObject3d.emit()}}},e.VglRectAreaLightHelper={mixins:[X],props:{/** If this is not the set the helper will take the color of the light. */color:{type:F},/** Name of the RectAreaLight being visualized. */light:{type:F}},data:function(){return{/**
         * Light object's UUID. This would be null if light object is not specified by `light` prop. Do
         * not set this data manually.
         */lightUuid:null}},computed:{/**
       * The THREE.RectAreaLightHelper instance. If any cameras specified by the name, it returns a
       * THREE.Object3D instance.
       */inst:function(){if(!this.lightUuid)return new t.Object3D;var e=this.vglNamespace.object3ds.get(this.light);return new t.RectAreaLightHelper(e)}},methods:{/** Set `lightUuid` data to given object's UUID. */setLightUuid:function(e){this.lightUuid=e?e.uuid:null,this.inst.update()}},beforeDestroy:function(){this.light!==void 0&&this.vglNamespace.object3ds.unlisten(this.light,this.setLightUuid)},watch:{inst:function(e){this.lightUuid&&this.color!==void 0&&Object.assign(e,{color:this.color}).update()},light:{handler:function(e,t){if(void 0!==t&&this.vglNamespace.object3ds.unlisten(t,this.setLightUuid),void 0!==e){this.vglNamespace.object3ds.listen(e,this.setLightUuid);var a=this.vglNamespace.object3ds.get(this.light);this.setLightUuid(a)}},immediate:!0},color:{handler:function(e){this.lightUuid&&(this.inst.color=e,this.inst.update())},immediate:!0}}},e.VglRenderer={mixins:[T],props:{/** Shader precision. Can be "highp", "mediump" or "lowp". */precision:F,/** Whether the canvas contains an alpha (transparency) buffer or not. */alpha:U,/** Whether the renderer will assume that colors have premultiplied alpha. */disablePremultipliedAlpha:U,/** Whether to perform antialiasing. */antialias:U,/** Whether the drawing buffer has a stencil buffer of at least 8 bits. */disableStencil:U,/**
       * A hint to the user agent indicating what configuration of GPU is suitable
       * for this WebGL context. Can be "high-performance", "low-power" or "default".
       */powerPreference:F,/** Whether to preserve the buffers until manually cleared or overwritten. */preserveDrawingBuffer:U,/** Whether the drawing buffer has a depth buffer of at least 16 bits. */disableDepth:U,/** Whether to use a logarithmic depth buffer. */logarithmicDepthBuffer:U,/** Name of the using camera. */camera:{type:Q,validator:O},/** Name of the target scene. */scene:{type:Q,validator:O},/** If set, use shadow maps in the scene. */shadowMapEnabled:U},computed:{/** The THREE.WebGLRenderer instance. */inst:function e(){var e=new t.WebGLRenderer({precision:this.precision,alpha:this.alpha,premultipliedAlpha:!this.disablePremultipliedAlpha,antialias:this.antialias,stencil:!this.disableStencil,preserveDrawingBuffer:this.preserveDrawingBuffer,depth:!this.disableDepth,logarithmicDepthBuffer:this.logarithmicDepthBuffer,powerPreference:this.powerPreference});return e.shadowMap.enabled=this.shadowMapEnabled,e}},methods:{/**
       * Set camera for rendering the scene. If canvas is already mounted, also calculates view size
       * or aspect ratio.
      */setCameraRef:function(e){this.cameraRef=e,this.$el&&(e&&R(e,this.$el.clientWidth,this.$el.clientHeight),this.requestRender(e&&this.sceneRef))},/** Set scene to be rendered. */setSceneRef:function(e){this.sceneRef=e,this.$el&&this.requestRender(e&&this.cameraRef)},/** Set camera for rendering the scene when `camera` prop is undefined. */setFallbackCamera:function(e){var t=e.keys();this.setCameraRef(1===t.length?e.get(t[0]):void 0)},/** Set scene to be rendered when `scene` prop is undefined. */setFallbackScene:function(e){var t=e.keys();this.setSceneRef(1===t.length?e.get(t[0]):void 0)},/**
       * Call render function at next tick. Even if this method was called multiple times, it will be
       * render just once.
       */requestRender:function(){var e=this;this.reservation||this.$nextTick(function(){if(0<e.reservation)e.inst.render(e.sceneRef,e.cameraRef);else if(!e.cameraRef&&e.vglNamespace.cameras.keys().length){if(void 0===e.camera){var t=e.vglNamespace.cameras.keys(),a=t.length;throw new ReferenceError("Cannot identify the camera. Multiple(".concat(a,") cameras are defined but camera prop is not given."))}else throw new ReferenceError("Cannot identify the camera. The camera named ".concat(e.camera," is not defined."));}else if(!e.sceneRef&&e.vglNamespace.scenes.keys().length)if(void 0===e.scene){var i=e.vglNamespace.cameras.keys(),s=i.length;throw new ReferenceError("Cannot identify the scene. Multiple(".concat(s,") scenes are defined but scene prop is not given."))}else throw new ReferenceError("Cannot identify the scene. The scene named ".concat(e.scene," is not defined."));e.reservation=0}),this.reservation=!arguments.length||(0>=arguments.length?void 0:arguments[0])?1:-1}},mounted:function(){this.inst.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.appendChild(this.inst.domElement),this.cameraRef&&R(this.cameraRef,this.$el.clientWidth,this.$el.clientHeight),this.requestRender(this.cameraRef&&this.sceneRef)},beforeDestroy:function(){this.camera===void 0?this.vglNamespace.cameras.unlisten(this.setFallbackCamera):this.vglNamespace.cameras.unlisten(this.camera,this.setCameraRef),this.scene===void 0?this.vglNamespace.scenes.unlisten(this.setFallbackScene):this.vglNamespace.scenes.unlisten(this.scene,this.setSceneRef),this.inst.dispose()},watch:{inst:function(e,t){this.$el&&(e.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.replaceChild(e.domElement,t.domElement),this.cameraRef&&this.sceneRef&&this.requestRender()),t.dispose()},camera:{handler:function(e,t){t===void 0?this.vglNamespace.cameras.unlisten(this.setFallbackCamera):this.vglNamespace.cameras.unlisten(t,this.setCameraRef),e===void 0?(this.vglNamespace.cameras.listen(this.setFallbackCamera),this.setFallbackCamera(this.vglNamespace.cameras)):(this.vglNamespace.cameras.listen(e,this.setCameraRef),this.setCameraRef(this.vglNamespace.cameras.get(e)))},immediate:!0},scene:{handler:function(e,t){t===void 0?this.vglNamespace.scenes.unlisten(this.setFallbackScene):this.vglNamespace.scenes.unlisten(t,this.setSceneRef),e===void 0?(this.vglNamespace.scenes.listen(this.setFallbackScene),this.setFallbackScene(this.vglNamespace.scenes)):(this.vglNamespace.scenes.listen(e,this.setSceneRef),this.setSceneRef(this.vglNamespace.scenes.get(e)))},immediate:!0}},render:function(e){var t=this;return e("div",[e("iframe",{style:{visibility:"hidden",width:"100%",height:"100%",marginRight:"-100%",border:"none"},on:{load:function(e){e.target.contentWindow.addEventListener("resize",function(){t.inst.setSize(t.$el.clientWidth,t.$el.clientHeight),t.cameraRef&&(R(t.cameraRef,t.$el.clientWidth,t.$el.clientHeight),t.sceneRef&&t.requestRender())},!1)}}},this.$slots.default)])}},e.VglRingGeometry={mixins:[ae],props:{/** Inner radius of the ring. */innerRadius:{type:P,default:.5},/** Outer radius of the ring. */outerRadius:{type:P,default:1},/** Number of segments along to the tangential direction. */thetaSegments:{type:P,default:8},/** Number of segments along to the radial direction. */phiSegments:{type:P,default:1},/** The starting angle. */thetaStart:{type:P,default:0},/** The central angle. */thetaLength:{type:P,default:2*G}},computed:{inst:function(){return new t.RingBufferGeometry(parseFloat(this.innerRadius),parseFloat(this.outerRadius),parseInt(this.thetaSegments,10),parseInt(this.phiSegments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglScene={mixins:[X],props:{/** the color, near and far parameters of the scene's fog */fog:_,/**
       * Expecting to accept a string representing a color.
       * Will be overwrited by backgroundTexture prop if both props are set
      */backgroundColor:F,/** Expecting to accept a string representing a texture name. */backgroundTexture:F},computed:{/** The THREE.Scene instance. */inst:function(){return new t.Scene}},methods:{/** Set scene's background property to given texture. */setBackgroundTexture:function(e){this.inst.background=e||null,this.vglObject3d.emit()},/** Emit an event in the `scenes` namespace. */emitAsScene:function(){this.vglNamespace.scenes.emit(this.name,this.inst)}},created:function(){this.vglObject3d.listen(this.emitAsScene)},beforeDestroy:function(){this.backgroundTexture!==void 0&&this.vglNamespace.textures.unlisten(this.backgroundTexture,this.setBackgroundTexture),this.vglNamespace.scenes.delete(this.name,this.inst),this.vglObject3d.unlisten(this.emitAsScene)},watch:{inst:{handler:function(e){this.fog!==void 0&&(this.inst.fog=k(this.fog)),this.backgroundColor!==void 0&&(this.inst.background=A(this.backgroundColor)),this.backgroundTexture!==void 0&&this.setBackgroundTexture(this.vglNamespace.textures.get(this.backgroundTexture)),this.vglNamespace.scenes.set(this.name,e)},immediate:!0},name:function(e,t){this.vglNamespace.scenes.delete(t,this.inst),this.vglNamespace.scenes.set(e,this.inst)},fog:function(e){this.inst.fog=k(e),this.vglObject3d.emit()},backgroundColor:function(e){this.inst.background=A(e),this.vglObject3d.emit()},backgroundTexture:{handler:function(e,t){t!==void 0&&this.vglNamespace.textures.unlisten(t,this.setBackgroundTexture),e!==void 0&&(this.vglNamespace.textures.listen(e,this.setBackgroundTexture),this.setBackgroundTexture(this.vglNamespace.textures.get(e)))},immediate:!0}}},e.VglShaderMaterial=ve,e.VglShadowMaterial={mixins:[te],computed:{/** The THREE.ShadowMaterial instance. */inst:function(){return new t.ShadowMaterial}}},e.VglShape={mixins:[Ne],computed:{/** The THREE.Shape instance. */inst:function(){var e=new t.Shape;return void 0!==this.path&&e.setFromPoints(V(this.path)),e}}},e.VglSphereGeometry={mixins:[ae],props:{/** Sphere radius. */radius:{type:P,default:1},/** Number of horizontal segments. */widthSegments:{type:P,default:8},/** Number of vertical segments. */heightSegments:{type:P,default:6},/** Specify horizontal starting angle. */phiStart:{type:P,default:0},/** Specify horizontal sweep angle size. */phiLength:{type:P,default:2*G},/** Specify vertical starting angle. */thetaStart:{type:P,default:0},/** Specify vertical sweep angle size. */thetaLength:{type:P,default:G}},computed:{inst:function(){return new t.SphereBufferGeometry(parseFloat(this.radius),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseFloat(this.phiStart),parseFloat(this.phiLength),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglSpotLight={mixins:[Z],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:P,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:P,default:1},/**
       * Maximum extent of the spotlight, in radians, from its direction.
       * Should be no more than Math.PI/2.
       */angle:{type:P,default:G/3},/**
       * Percent of the spotlight cone that is attenuated due to penumbra.
       * Takes values between zero and 1.
       */penumbra:{type:P,default:0},/** The spotlight's pointing position. */target:z},computed:{/** The THREE.SpotLight instance. */inst:function(){return new t.SpotLight}},beforeDestroy:function(){this.inst.target.parent&&this.inst.target.parent.remove(this.inst.target)},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay),angle:parseFloat(this.angle),penumbra:parseFloat(this.penumbra)}),this.target&&e.target.position.copy(N(this.target)),this.parent&&this.parent.add(e.target)},immediate:!0},parent:function(e){e.add(this.inst.target)},distance:function(e){this.inst.distance=parseFloat(e),this.vglObject3d.emit()},decay:function(e){this.inst.decay=parseFloat(e),this.vglObject3d.emit()},angle:function(e){this.inst.angle=parseFloat(e),this.vglObject3d.emit()},penumbra:function(e){this.inst.penumbra=parseFloat(e),this.vglObject3d.emit()},target:function(e){this.inst.target.position.copy(N(e)),this.vglObject3d.emit()}}},e.VglSpotLightHelper={mixins:[X],props:{/** If this is not the set the helper will take the color of the light. */color:{type:F},/** Name of the spot light being visualized. */light:F},data:function(){return{/**
         * Light object's UUID. This would be null if light object is not specified by `light` prop. Do
         * not set this data manually.
         */lightUuid:null}},computed:{/**
       * The THREE.SpotLightHelper instance. If any cameras specified by the name, it returns a
       * THREE.Object3D instance.
       */inst:function(){if(!this.lightUuid)return new t.Object3D;var e=this.vglNamespace.object3ds.get(this.light);return new t.SpotLightHelper(e)}},methods:{/** Set `lightUuid` data to given object's UUID. */setLightUuid:function(e){this.lightUuid=e?e.uuid:null,this.inst.update()}},beforeDestroy:function(){this.light!==void 0&&this.vglNamespace.object3ds.unlisten(this.light,this.setLightUuid)},watch:{inst:function(e){this.lightUuid&&this.color!==void 0&&Object.assign(e,{color:this.color}).update()},light:{handler:function(e,t){if(void 0!==t&&this.vglNamespace.object3ds.unlisten(t,this.setLightUuid),void 0!==e){this.vglNamespace.object3ds.listen(e,this.setLightUuid);var a=this.vglNamespace.object3ds.get(this.light);this.setLightUuid(a)}},immediate:!0},color:{handler:function(e){this.lightUuid&&(this.inst.color=e,this.inst.update())},immediate:!0}}},e.VglSprite={mixins:[ie],props:{/** Name of the material, defining the object's appearance. */material:{type:Q,validator:O}},computed:{/** The THREE.Sprite instance. */inst:function(){return new t.Sprite}}},e.VglSpriteMaterial={mixins:[ne],props:{/** CSS style color of the material. */color:{type:F,default:"#fff"},/** The texture map of the material. */map:{type:Q,validator:O}},computed:{/** The THREE.SpriteMaterial instance. */inst:function(){return new t.SpriteMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e),this.update()}}},e.VglTetrahedronGeometry={mixins:[ae],props:{/** Radius of the tetrahedron. */radius:{type:P,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a tetrahedron. */detail:{type:P,default:0}},computed:{inst:function(){return new t.TetrahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglTextGeometry={mixins:[he],props:{/** The text that needs to be shown. */text:{type:F,default:""},/** The path or URL to the facetype json file. This can also be a Data URI. */font:F,/** Size of the text. */size:{type:P,default:100},/** Thickness to extrude text. */height:{type:P,default:50},/** Number of points on the curves. */curveSegments:{type:P,default:12},/** Turn on bevel. */bevelEnabled:U,/** How deep into text bevel goes. */bevelThickness:{type:P,default:10},/** How far from text outline is bevel. */bevelSize:{type:P,default:8},/** Number of bevel segments. */bevelSegments:{type:P,default:3}},data:function(){return{f:void 0}},computed:{inst:function(){return this.f===void 0?new t.BufferGeometry:new t.TextBufferGeometry(this.text,{font:fe[this.f],size:parseFloat(this.size),height:parseFloat(this.height),curveSegments:parseInt(this.curveSegments,10),bevelEnabled:this.bevelEnabled,bevelThickness:parseFloat(this.bevelThickness),bevelSize:parseFloat(this.bevelSize),bevelSegments:parseInt(this.bevelSegments,10)})}},watch:{font:{handler:function(e){var a=this;fe[e]?fe[e].isFont?this.f=e:fe[e].push(function(){e===a.font&&(a.f=e)}):(fe[e]=[function(){e===a.font&&(a.f=e)}],new t.FontLoader().load(e,function(t){var i=fe[e];fe[e]=t,i.forEach(function(e){e()}),a.vglNamespace.geometries.emit(a.name,a.inst)})),this.vglNamespace.geometries.emit(this.name,this.inst)},immediate:!0}}},e.VglTexture={inject:{vglNamespace:{default:function(){throw new Error("VueGL components must be wraped by VglNamespace component.")}}},props:{/** The path or URL to the file. This can also be a Data URI. */src:F,name:{type:Q,validator:O},mapping:{type:F,default:"uv"},wrapS:{type:F,default:"clamp-to-edge"},wrapT:{type:F,default:"clamp-to-edge"},magFilter:{type:F,default:"linear"},minFilter:{type:F,default:"linear-mip-map-linear"},anisotropy:{type:P,default:1},format:F,type:{type:F,default:"unsigned-byte"},offset:H,repeat:H,rotation:{type:P,default:0},center:H,premultiplyAlpha:U,unpackAlignment:{type:P,default:4},encoding:{type:F,default:"linear"}},computed:{/** The THREE.Texture instance. */inst:function(){var e=this;return new t.TextureLoader().load(this.src,function(t){e.format&&Object.assign(t,{format:ce[e.format]}),e.update()})}},methods:{/** Emit an event in the `textures` namespace. */update:function(){this.name!==void 0&&this.vglNamespace.textures.emit(this.name,this.inst)}},beforeDestroy:function(){this.name!==void 0&&this.vglNamespace.textures.delete(this.name,this.inst)},watch:{inst:{handler:function(e){Object.assign(e,{mapping:de[this.mapping],wrapS:pe[this.wrapS],wrapT:pe[this.wrapT],magFilter:me[this.magFilter],minFilter:me[this.minFilter],anisotropy:parseInt(this.anisotropy,10),type:ue[this.type],rotation:parseFloat(this.rotation),premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:parseInt(this.unpackAlignment,10),encoding:ge[this.encoding]}),this.offset&&e.offset.copy(x(this.offset)),this.repeat&&e.repeat.copy(x(this.repeat)),this.center&&e.center.copy(x(this.center)),this.name!==void 0&&this.vglNamespace.textures.set(this.name,e)},immediate:!0},name:function(e,t){t!==void 0&&this.vglNamespace.textures.delete(t,this.inst),e!==void 0&&this.vglNamespace.textures.set(e,this.inst)},mapping:function(e){this.inst.mapping=de[e],this.update()},wrapS:function(e){this.inst.wrapS=pe[e],this.update()},wrapT:function(e){this.inst.wrapT=pe[e],this.update()},magFilter:function(e){this.inst.magFilter=me[e],this.update()},minFilter:function(e){this.inst.minFilter=me[e],this.update()},anisotropy:function(e){this.inst.anisotropy=parseInt(e,10),this.update()},format:function(e){this.inst.format=ce[e],this.update()},type:function(e){this.inst.type=ue[e],this.update()},offset:function(e){this.inst.offset.copy(x(e)),this.update()},repeat:function(e){this.inst.repeat.copy(x(e)),this.update()},rotation:function(e){this.inst.rotation=parseFloat(e),this.update()},center:function(e){this.inst.center.copy(x(e)),this.update()},premultiplyAlpha:function(e){this.inst.premultiplyAlpha=e,this.update()},unpackAlignment:function(e){this.inst.unpackAlignment=parseInt(e,10),this.update()},encoding:function(e){this.inst.encoding=ge[e],this.update()}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},e.VglTorusGeometry={mixins:[ae],props:{/** Radius of the torus. */radius:{type:P,default:1},/** Diamiter of the tube. */tube:{type:P,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:P,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:P,default:6},/** The central angle. */arc:{type:P,default:2*G}},computed:{inst:function(){return new t.TorusBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.radialSegments,10),parseInt(this.tubularSegments,10),parseFloat(this.arc))}}},e.VglTorusKnotGeometry={mixins:[ae],props:{/** Radius of the torus. */radius:{type:P,default:1},/** Diamiter of the tube. */tube:{type:P,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:P,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:P,default:64},/**
       * This value determines how many times the geometry winds
       * around its axis of rotational symmetry.
       */p:{type:P,default:2},/**
       * This value determines how many times the geometry winds
       * around a circle in the interior of the torus.
       */q:{type:P,default:3}},computed:{inst:function(){return new t.TorusKnotBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.tubularSegments,10),parseInt(this.radialSegments,10),parseInt(this.p,10),parseInt(this.q,10))}}},Object.defineProperty(e,"__esModule",{value:!0})});
